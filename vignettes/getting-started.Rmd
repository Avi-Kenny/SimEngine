# Overview

```{r}

library(magrittr) # !!!!! Finish NAMESSPACES chapter and get rid of this
library(parallel) # !!!!! Finish NAMESSPACES chapter and get rid of this

# !!!!! Add list levels (see z.stepped.wedge)

# !!!!! Links to all functions in docs

# !!!!! Copy everything in from z_stepped_wedge and z_572_paper

# !!!!! Script: Throw warning if any column names are duplicated/overwritten

# !!!!! Print simulation object
print(sim)


# !!!!! summary(): Throw warning if any column names are duplicated/overwritten
# Make it such that you can't use expressions like `truth=C$lambda` here (i.e. 
#     you can't pass constants); instead, add constants to results data frame
#     and reference by quotes like the others; alternatively ...

# !!!!! Coverage; see z.stepped_wedge
# !!!!! Error handling

```



# Minimal working example of cluster-parallelized simulation

```{r}

# Code to run in Slurm:
#   sbatch --export=run='first' run_r.sh
#   sbatch --array=1-10 --depend=afterok:101 run_r.sh
#   sbatch --export=run='last' --depend=afterok:102 run_r.sh

# Submitted batch job 101
# Submitted batch job 102
# Submitted batch job 103

# Code to run in SGE:
#   qsub -v run='first' run_r.sh
#   qsub -t 1-10 -hold_jid 101 run_r.sh
#   qsub -v run='last' -hold_jid 102 run_r.sh

# Your job-array 101.1-1:1 ("run_r_Bayes.sh") has been submitted
# Your job-array 102.2-9:1 ("run_r_Bayes.sh") has been submitted
# Your job-array 103.10-10:1 ("run_r_Bayes.sh") has been submitted


# Code outline:
# sim <- new_sim()
# sim %<>% set_config(jms="SGE")
# sim %<>% run_once_first({...})
# sim %<>% run("my_script")
# sim %<>% run_once_last({...})

sim <- new_sim()
sim %<>% set_config(jms="SGE") # !!!!! Need alternative for unsupported JMS
# !!!!! Use the standard acronym here and in the documentation; HPC?
# !!!!! Add option to change where sim_obj and sim_data files are stored

sim %<>% run_once_first({
  
  sim %<>% set_config(
    num_sim = 10,
    parallel = "outer"
  )
  
  # if .tid==1, run the code in this block
  # otherwise, return the already-created sim_obj
  
  create_data <- function (population_size) {
    x <- rnorm(n=population_size, mean=5, sd=0.1)
    y <- 2*x + rnorm(n=1, mean=0, sd=0.5)
    return (data.frame(x=x, y=y))
  }
  
  take_sample <- function (data, sample_size) {
    sample <- sample(1:nrow(data), size=sample_size)
    return (data[sample,])
  }
  
  sim %<>% add_creator(create_data)
  sim %<>% add_method(take_sample)
  
  sim %<>% set_levels(
    sample_size = c(10, 50, 200)
  )
  
  sim %<>% add_script(
    "my_script",
    function () {
      # !!!!! do stuff
    }
  )
  
  # !!!!! save sim_obj
  
})

sim %<>% run("my_script") # !!!!! handle TIDs

# !!!!! save results here

# !!!!! need to determine now if job is last

sim %<>% run_once_last({
  
  # if .tid==max(.tid), run the code in this block
  # otherwise, do nothing
  
  # !!!!! Merge datasets
  
  # !!!!! Print and visualize results
  
  # !!!!! Save final sim_obj and delete intermediate sim_objs
  
})

```


!!!!! MISC !!!!!

We recommend the compact syntax above, but it sometimes may be useful to create a function and add it to your simulation object afterwards.

```{r}
my_function <- function (n_patients) {...}
sim %<>% add_creator("create_rct_data", my_function)
```

For simple simulations, you will often write creators that return dataframes, but you can return more complex objects, such as a list of multiple dataframes, a network data structure, etc.



# !!!!! TESTING 1 !!!!!

```{r}

sim <- new_sim()

create_rct_data <- function (num_patients) {
  df <- data.frame(
    "patient_id" = integer(),
    "group" = character(),
    "outcome" = double(),
    stringsAsFactors = FALSE
  )
  for (i in 1:num_patients) {
    group <- ifelse(sample(c(0,1), size=1)==1, "treatment", "control")
    treatment_effect <- ifelse(group=="treatment", -7, 0)
    outcome <- rnorm(n=1, mean=130, sd=5) + treatment_effect
    df[i,] <- list(i, group, outcome)
  }
  return (df)
}

sim %<>% add_creator(create_rct_data)

estimator_1 <- function(df) {
  n <- nrow(df)
  true_prob <- 0.5
  sum_t <- sum(df$outcome * (df$group=="treatment"))
  sum_c <- sum(df$outcome * (df$group=="control"))
  return ( sum_t/(n*true_prob) - sum_c/(n*(1-true_prob)) )
}
estimator_2 <- function(df) {
  n <- nrow(df)
  est_prob <- sum(df$group=="treatment") / n
  sum_t <- sum(df$outcome * (df$group=="treatment"))
  sum_c <- sum(df$outcome * (df$group=="control"))
  return ( sum_t/(n*est_prob) - sum_c/(n*(1-est_prob)) )
}

sim %<>% add_method(estimator_1)
sim %<>% add_method(estimator_2)

sim %<>% set_levels(
  estimator = c("estimator_1", "estimator_2"),
  num_patients = c(50, 100, 200)
)

# !!!!!
my_func <- function() {return(1)}

sim %<>% add_script(
  "my script",
  function() {
    df <- create_rct_data(L$num_patients)
    estimate <- do.call(L$estimator, list(df))
    # my_func <- function() {return(2)}
    x <- my_func() # !!!!!
    return (
      list("estimate" = x) # !!!!!
      # list("estimate" = estimate)
    )
  }
)

sim %<>% set_config(
  num_sim = 100,
  parallel = "outer"
)

sim %<>% run("my script")

sim %>% summary()

sim %>% summary(
  bias = list(name="bias_ate", truth=-7, estimate="estimate"),
  mse = list(name="mse_ate", truth=-7, estimate="estimate")
)

```



# !!!!! TESTING 2 !!!!!

```{r}

# sim_obj <- new_sim()
# sim_obj %<>% set_levels(
#   method = c("estimator_1", "estimator_2"),
#   num_patients = c(20, 40, 80)
# )

```

# Overview

```{r}

library(magrittr) # !!!!! Finish NAMESSPACES chapter and get rid of this
library(parallel) # !!!!! Finish NAMESSPACES chapter and get rid of this

# !!!!! Add list levels (see z.stepped.wedge)

# The notion of "simulation constants" is more of an organizational convenience
#   than anything else. As one might guess, a simulation constant is something 
#   that does not change across your entire set of simulations. You could just
#    as easily hard-code values in your code, but it's often easier to have
#    these declared at a separate section so that they can be easily modified if
#    needed.
sim %<>% add_constants(
  "lambda2" = 4, # !!!!! testing
  "lambda3" = 6 # !!!!! testing
)

# !!!!! Links to all functions in docs

# !!!!! Copy everything in from z_stepped_wedge and z_572_paper

# !!!!! Script: Throw warning if any column names are duplicated/overwritten

# !!!!! Print simulation object
print(sim)

# Run only simulations with UIDs 3,6
sim %<>% run("my script", sim_uids=c(3,6))

# Summarize results (with standard deviations)
# !!!!! Throw warning if any column names are duplicated/overwritten
# Make it such that you can't use expressions like `truth=C$lambda` here (i.e. 
#     you can't pass constants); instead, add constants to results data frame
#     and reference by quotes like the others; alternatively
summary(
  sim,
  sd = list(name="sd_lambda", x="lambda_hat"),
  bias = list(name="bias_lambda", truth="lambda", estimate="lambda_hat")
)

# !!!!! Coverage; see z.stepped_wedge
# !!!!! Error handling

```



# Using previously-defined functions

Above, we created new functions and named them "create_rct" and "OLS". It's also easy to use previously-defined functions. You can give the functions a new name, or use the name of the function.

```{r}

create_data <- function(n, sigma) {
  x <- runif(n)
  y <- 4*x + rnorm(n, mean=0, sd=sigma)
  return (data.frame(x=x,y=y))
}

ols <-   function(data) {
  model <- lm(y~x, data=data)
  return (model$coefficients[["x"]])
}

sim %<>% add_creator(create_data)
sim %<>% add_method(ols)

```



# !!!!! TESTING 1 !!!!!

```{r}

sim <- new_sim()
create_rct_data <- function (num_patients) {
  df <- data.frame(
    "patient_id" = integer(),
    "group" = character(),
    "outcome" = double(),
    stringsAsFactors = FALSE
  )
  for (i in 1:num_patients) {
    group <- ifelse(sample(c(0,1), size=1)==1, "treatment", "control")
    treatment_effect <- ifelse(group=="treatment", -7, 0)
    outcome <- rnorm(n=1, mean=130, sd=5) + treatment_effect
    df[i,] <- list(i, group, outcome)
  }
  return (df)
}
sim %<>% add_creator(create_rct_data)
rm(create_rct_data)
estimator_1 <- function(df) {
  n <- nrow(df)
  true_prob <- 0.5
  sum_t <- sum(df$outcome * (df$group=="treatment"))
  sum_c <- sum(df$outcome * (df$group=="control"))
  return ( sum_t/(n*true_prob) - sum_c/(n*(1-true_prob)) )
}
estimator_2 <- function(df) {
  n <- nrow(df)
  est_prob <- sum(df$group=="treatment") / n
  sum_t <- sum(df$outcome * (df$group=="treatment"))
  sum_c <- sum(df$outcome * (df$group=="control"))
  return ( sum_t/(n*est_prob) - sum_c/(n*(1-est_prob)) )
}
sim %<>% add_method(estimator_1)
sim %<>% add_method(estimator_2)
rm(estimator_1)
rm(estimator_2)
sim %<>% set_levels(
  estimator = c("estimator_1", "estimator_2"),
  num_patients = c(20, 40, 80)
)
sim %<>% add_script(
  "my script",
  function() {
    df <- create_rct_data(L$num_patients)
    estimate <- use_method(L$estimator, df)
    return (
      list("estimate" = estimate)
      # list("est"=L$estimator, "num"=L$num_patients)
    )
  }
)
sim %<>% set_config(
  num_sim = 10,
  parallel = "none"
)
sim %<>% run("my script")

```


# !!!!! TESTING 2 !!!!!

```{r}

# sim_obj <- new_sim()
# sim_obj %<>% set_levels(
#   method = c("estimator_1", "estimator_2"),
#   num_patients = c(20, 40, 80)
# )

```
